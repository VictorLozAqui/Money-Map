import { useEffect } from 'react';
import { collection, query, where, getDocs, addDoc, updateDoc, doc, Timestamp } from 'firebase/firestore';
import { db } from '../services/firebase';
import { useFamily } from '../contexts/FamilyContext';
import { RecurringExpense } from '../types';

export const useRecurringExpensesProcessor = () => {
  const { family } = useFamily();

  useEffect(() => {
    if (!family) return;

    const processRecurringExpenses = async () => {
      try {
        const now = new Date();
        const currentMonth = now.toISOString().slice(0, 7); // "YYYY-MM"
        const currentDay = now.getDate();
        const currentMonthNum = now.getMonth() + 1; // 1-12
        const currentYear = now.getFullYear();

        // Buscar gastos recorrentes ativos
        const q = query(
          collection(db, 'recurringExpenses'),
          where('familyId', '==', family.id),
          where('active', '==', true)
        );

        const snapshot = await getDocs(q);
        const recurringExpenses = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as RecurringExpense[];

        for (const recurring of recurringExpenses) {
          // Se for MENSAL (ou não tiver frequência definida - compatibilidade com gastos antigos)
          if (recurring.frequencia === 'mensal' || !recurring.frequencia) {
            // Verifica se já foi processado neste mês
            if (recurring.lastProcessedMonth === currentMonth) {
              continue;
            }

            // Verifica se já passou o dia do mês
            if (currentDay >= recurring.diaDoMes) {
              // Calcula a data correta (dia específico do mês atual)
              const targetDate = new Date();
              targetDate.setDate(recurring.diaDoMes);
              targetDate.setHours(12, 0, 0, 0); // Meio-dia para evitar problemas de timezone

              // Cria o gasto automático
              await addDoc(collection(db, 'expenses'), {
                familyId: family.id,
                nome: `${recurring.nome} (Automático)`,
                valor: recurring.valor,
                tipo: recurring.tipo,
                data: Timestamp.fromDate(targetDate),
                addedBy: recurring.createdBy,
                createdAt: Timestamp.now(),
                isAutoGenerated: true
              });

              // Atualiza o último mês processado
              await updateDoc(doc(db, 'recurringExpenses', recurring.id), {
                lastProcessedMonth: currentMonth
              });
            }
          }
          // Se for ANUAL
          else if (recurring.frequencia === 'anual') {
            // Verifica se já foi processado neste ano
            if (recurring.lastProcessedYear === currentYear) {
              continue;
            }

            // Verifica se já chegou o mês e o dia
            if (
              currentMonthNum > (recurring.mesDoAno || 1) ||
              (currentMonthNum === (recurring.mesDoAno || 1) && currentDay >= recurring.diaDoMes)
            ) {
              // Calcula a data correta (dia e mês específicos do ano atual)
              const targetDate = new Date(currentYear, (recurring.mesDoAno || 1) - 1, recurring.diaDoMes, 12, 0, 0, 0);

              // Cria o gasto automático
              await addDoc(collection(db, 'expenses'), {
                familyId: family.id,
                nome: `${recurring.nome} (Automático)`,
                valor: recurring.valor,
                tipo: recurring.tipo,
                data: Timestamp.fromDate(targetDate),
                addedBy: recurring.createdBy,
                createdAt: Timestamp.now(),
                isAutoGenerated: true
              });

              // Atualiza o último ano processado
              await updateDoc(doc(db, 'recurringExpenses', recurring.id), {
                lastProcessedYear: currentYear
              });
            }
          }
        }
      } catch (error) {
        console.error('Erro ao processar gastos recorrentes:', error);
      }
    };

    // Executa ao carregar e a cada 1 hora
    processRecurringExpenses();
    const interval = setInterval(processRecurringExpenses, 60 * 60 * 1000);

    return () => clearInterval(interval);
  }, [family]);
};

